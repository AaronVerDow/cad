// Maximim card width (default 64)
card_size_x = 64;

// Maximum card lenght (default 102)
card_size_y = 102;

// Maximum internal height (default 30)
height = 30;

// Thickness of the walls (default 1.75)
wall_thickness = 0.8;

// Separation between upper and lower (default 0.5)
tolerance = 0.5;

/* {{{ %%SECTION_HEADER%%
 * * * *
 * This header information is automatically generated by KodeUtils.
 *
 * File 'tarjetero.scad' edited by kwendenarmo, last modified: 2017-04-15.
 * This file is part of 'tarjetero' package, please see the readme files for more information about this file and this package.
 *
 * Copyright (C) 2017 by kwendenarmo <kwendenarmo@akornsys-rdi.net>
 * Released under the GNU GPLv3
 *
 *    This program is free software: you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation, either version 3 of the License, or
 *    (at your option) any later version.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * * * *
 * %%EOS_HEADER%% }}}
 */

$fn=60;

//Standard case size 64x102x30

display="";
if (display=="") assembled();
if (display=="dixit_upper.stl") upper();
if (display=="dixit_lower.stl") lower();
if (display=="dixit_tokens.stl") vote_tokens();

module assembled() {
    lower();
    translate([card_size_x+(wall_thickness*2+tolerance)*2+5,0,0]) upper();
    translate([card_size_x*3+(wall_thickness*2+tolerance)*3+5,0,0]) vote_tokens();
}

pad=0.1;
token=34;
token_h=11;
outer_token_box=[token*3+wall_thickness*4,token*2+wall_thickness*3,token_h+wall_thickness];
token_box=[token,token,token_h+pad];
finger=20;
module vote_tokens() {
    difference() {
        cube(outer_token_box);
        for(y=[wall_thickness:token+wall_thickness:(token+wall_thickness)*2]) {
            for(x=[wall_thickness:token+wall_thickness:(token+wall_thickness)*3]) {
                translate([x,y,wall_thickness])
                cube(token_box);
            }
        }
        for(y=[0,token*2+wall_thickness*3]) {
            for(x=[wall_thickness+token/2:token+wall_thickness:(token+wall_thickness)*3]) {
                translate([x,y,-pad])
                cylinder(d=finger,h=token_h+wall_thickness+pad*2);
            }
        }
    }
}

module upper() {
    box_x=card_size_x+(wall_thickness*2+tolerance)*2;
    box_y=card_size_y+(wall_thickness*2+tolerance)*2;
    box_z=height+wall_thickness;
    inner_box_x=card_size_x+(wall_thickness+tolerance)*2;
    inner_box_y=card_size_y+(wall_thickness+tolerance)*2;

    difference() {
        union() {
            cube([box_x,box_y,box_z]);
        }
        union() {
            translate([wall_thickness,wall_thickness,wall_thickness]) cube([inner_box_x,inner_box_y,height+1]);
            translate([-1,box_y/3,(box_z/8)*3]) hull() {
                cube([box_x+2,box_y/3,1]);
                translate([0,-box_y/3+box_y/8,(box_z/8)*5]) cube([box_x+2,(box_y/8)*6,1]);
            }
        }
    }
}

module lower() {
    box_x=card_size_x+(wall_thickness)*2;
    box_y=card_size_y+(wall_thickness)*2;
    box_z=height+wall_thickness;

    difference() {
        union() {
            cube([box_x,box_y,box_z]);
        }
        union() {
            translate([wall_thickness,wall_thickness,wall_thickness]) cube([card_size_x,card_size_y,height+1]);
            translate([box_x/3,-1,(box_z/8)*3]) hull() {
                cube([box_x/3,box_y+2,1]);
                translate([-box_x/3+box_x/8,0,(box_z/8)*5]) cube([(box_x/8)*6,box_y+2,1]);
            }
        }
    }
}
